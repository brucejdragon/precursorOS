// ===========================================================================
//
//             Copyright (C) 2004-2005 Bruce Johnston
//
// ===========================================================================
//
//   //osdev/precursor/Source/Kernel/Architecture/x86/HAL/KernelDisplay_x86_Vga.c
//
// ===========================================================================
//
//	Originating Author:	BruceJ
//	Originating Date:	2004/Sep/25
//
// ===========================================================================
///
/// \file
///
/// \brief	This file implements the KernelDisplay class for standard VGA on the
///			x86 architecture.
///
/// Many of the VGA hardware details came from FreeVGA. It is a really great
/// source of information:
/// - http://www.osdever.net/FreeVGA/vga/vga.htm
/// .
///
/// Also, the code to set the correct VGA text mode (font + registers) is adapted
/// from demo code written by Chris Giese:
/// - http://my.execpc.com/~geezer/osd/graphics/modes.c
/// .
// ===========================================================================


#include <stddef.h>
#include <stdint.h>
#include "IO.h"
#include "Kernel/HAL/KernelDisplay.h"
#include "Kernel/KCommon/KMem.h"
#include "Kernel/KCommon/KDebug.h"
#include "Kernel/HAL/Processor.h"
#include "Kernel/HAL/Mem.h"


/// \brief	The default background color for the KernelDisplay.
static const KernelDisplayColor DEFAULT_BACKGROUND_COLOR = KDISPLAY_COLOR_LIGHTBLUE;

/// \brief	The default foreground color for the KernelDisplay.
static const KernelDisplayColor DEFAULT_FOREGROUND_COLOR = KDISPLAY_COLOR_WHITE;

/// \brief	The default number of space characters to move to the right when tabbing.
static const int TAB_SIZE = 4;	// Anything else is unnatural!

/// \brief	The base virtual address of VGA memory.
static uint16_t* const VIDEO_MEM_BASE = (uint16_t*) (KERNEL_VIRTUAL_BASE + 0x000B8000);


/// \brief	Defines local constants for the KernelDisplay class.
enum KernelDisplay_consts
{
	VGA_AC_INDEX		= 0x3C0,	///< Attribute controller address register (also data write).
	VGA_AC_WRITE		= 0x3C0,	///< Attribute controller data write register (also address).
	VGA_MISC_WRITE		= 0x3C2,	///< Miscellaneous output write register.
	VGA_SEQ_INDEX		= 0x3C4,	///< Sequencer address register.
	VGA_SEQ_DATA		= 0x3C5,	///< Sequencer data register.
	VGA_GC_INDEX 		= 0x3CE,	///< Graphics controller address register.
	VGA_GC_DATA 		= 0x3CF,	///< Graphics controller data register.
	VGA_CRTC_INDEX		= 0x3D4,	///< CRT controller address register.
	VGA_CRTC_DATA		= 0x3D5,	///< CRT controller data register.
	VGA_INSTAT_READ		= 0x3DA,	///< Input status #1 register.
	VGA_NUM_SEQ_REGS	= 5,		///< Total number of sequencer registers.
	VGA_NUM_CRTC_REGS	= 25,		///< Total number of CRT controller registers.
	VGA_NUM_GC_REGS		= 9,		///< Total number of graphics controller registers.
	VGA_NUM_AC_REGS		= 21		///< Total number of attribute controller registers.
};




/// \brief	Implementation of KernelDisplay.
struct KernelDisplayStruct
{
	KernelDisplayColor	m_backgroundColor;	///< The current background color of the display.
	KernelDisplayColor	m_foregroundColor;	///< The current foreground color of the display.
	int					m_column;			///< The column of the current output position.
	int					m_row;				///< The row of the current output position.
};



/// \brief	The one-and-only instance of KernelDisplay.
static volatile KernelDisplay s_instance;


/// \brief	The map from KernelDisplayColor values to VGA text-mode color codes.
///
/// \note
/// This array is static rather than a member of KernelDisplayStruct because it is easier to
/// initialize it this way.
static const uint16_t s_colorMap[] =
{
	// MAINTENANCE NOTE: The values here are from the VGA spec. Their indices match their
	// corresponding colors in the definition of KernelDisplayColor.
	0x0000,	// black
	0x000F,	// white
	0x0008,	// dark gray
	0x0007,	// light gray
	0x0004,	// dark red
	0x000C,	// light red
	0x0002,	// dark green
	0x000A,	// light green
	0x0001,	// dark blue
	0x0009,	// light blue
	0x0003,	// dark cyan
	0x000B,	// light cyan
	0x0005,	// magenta
	0x000D,	// pink
	0x0006,	// brown
	0x000E	// yellow
};



// Private functions

/// \brief	Creates a 16-bit word that contains character and attribute data suitable for output
///			to VGA memory.
///
/// \param ch				the character to display. This is an unsigned type to ensure that
///							the character number is not sign-extended when it is widened to 16
///							bits.
/// \param attributeMask	the attribute mask to combine with the character data.
static inline uint16_t KernelDisplay_makeDisplayData( uint8_t ch, uint16_t attributeMask )
{
	return ((uint16_t) ch | attributeMask);
}


/// \brief	Creates a 16-bit mask that can be used to set the attribute byte of a character in
///			VGA memory.
///
/// \param kdisplay	the KernelDisplay.
///
/// The background color occupies bits 7-4 of the attribute byte, and therefore bits 15-12 of the
/// mask. The foreground color occupies bits 3-0 of the attribute byte, and therefore bits 11-8
/// of the mask.
static inline uint16_t KernelDisplay_makeAttributeMask( KernelDisplay* kdisplay )
{
	KDebug_assertArg( kdisplay != NULL );

	return
		((s_colorMap[kdisplay->m_backgroundColor] << 12) |
		 (s_colorMap[kdisplay->m_foregroundColor] << 8));
}


/// \brief	Moves all text currently on the screen up by a specified number of lines and creates
///			the same number of blank lines at the bottom of the screen.
///
/// \param kdisplay	the KernelDisplay.
/// \param numLines	the number of lines by which to scroll.
///
/// In absolute terms, the current output location is not changed. However, relative to the text
/// begin scrolled, the current ouptput location moves down by \a numLines rows.
static void KernelDisplay_scroll( KernelDisplay* kdisplay, int numLines )
{
	KDebug_assertArg( kdisplay != NULL );

	// Start numLines below the top, and end right at the bottom.
	const uint16_t* const	source	= VIDEO_MEM_BASE + (KDISPLAY_NUM_COLUMNS * numLines);
	const size_t			length	= KDISPLAY_NUM_COLUMNS * (KDISPLAY_NUM_ROWS - numLines);

	KMem_move( VIDEO_MEM_BASE, source, length * sizeof( uint16_t ) );	// Length in bytes!

	// dest should point at the beginning of the first row to be blanked out.
	uint16_t* dest				= VIDEO_MEM_BASE + length;
	const uint16_t* const end	= source + length;

	uint16_t attributeMask	= KernelDisplay_makeAttributeMask( kdisplay );
	uint16_t displayData	= KernelDisplay_makeDisplayData( ' ', attributeMask );

	// Can't use KMem_set() for 16-bit values...
	while (dest != end)
	{
		*dest++ = displayData;
	}
}



/// \brief	Writes the appropriate text-mode font data to the VGA memory.
///
/// \note
/// This code has been adapted from code written by Chris Giese. The original code and usage notes
/// are at this URL: http://my.execpc.com/~geezer/osd/graphics/modes.c. The values used to
/// initialize the fonts may have been modified for aesthetic reasons.
static void KernelDisplay_initFont( void )
{
	// Contains font data for the high-res text mode font.
	static uint8_t _8x8_font[] =	// There is exactly 2K worth of data here.
	{
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x7E, 0x81, 0xA5, 0x81, 0xBD, 0x99, 0x81, 0x7E,
	0x7E, 0xFF, 0xDB, 0xFF, 0xC3, 0xE7, 0xFF, 0x7E,
	0x6C, 0xFE, 0xFE, 0xFE, 0x7C, 0x38, 0x10, 0x00,
	0x10, 0x38, 0x7C, 0xFE, 0x7C, 0x38, 0x10, 0x00,
	0x38, 0x7C, 0x38, 0xFE, 0xFE, 0x92, 0x10, 0x7C,
	0x00, 0x10, 0x38, 0x7C, 0xFE, 0x7C, 0x38, 0x7C,
	0x00, 0x00, 0x18, 0x3C, 0x3C, 0x18, 0x00, 0x00,
	0xFF, 0xFF, 0xE7, 0xC3, 0xC3, 0xE7, 0xFF, 0xFF,
	0x00, 0x3C, 0x66, 0x42, 0x42, 0x66, 0x3C, 0x00,
	0xFF, 0xC3, 0x99, 0xBD, 0xBD, 0x99, 0xC3, 0xFF,
	0x0F, 0x07, 0x0F, 0x7D, 0xCC, 0xCC, 0xCC, 0x78,
	0x3C, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x7E, 0x18,
	0x3F, 0x33, 0x3F, 0x30, 0x30, 0x70, 0xF0, 0xE0,
	0x7F, 0x63, 0x7F, 0x63, 0x63, 0x67, 0xE6, 0xC0,
	0x99, 0x5A, 0x3C, 0xE7, 0xE7, 0x3C, 0x5A, 0x99,
	0x80, 0xE0, 0xF8, 0xFE, 0xF8, 0xE0, 0x80, 0x00,
	0x02, 0x0E, 0x3E, 0xFE, 0x3E, 0x0E, 0x02, 0x00,
	0x18, 0x3C, 0x7E, 0x18, 0x18, 0x7E, 0x3C, 0x18,
	0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00,
	0x7F, 0xDB, 0xDB, 0x7B, 0x1B, 0x1B, 0x1B, 0x00,
	0x3E, 0x63, 0x38, 0x6C, 0x6C, 0x38, 0x86, 0xFC,
	0x00, 0x00, 0x00, 0x00, 0x7E, 0x7E, 0x7E, 0x00,
	0x18, 0x3C, 0x7E, 0x18, 0x7E, 0x3C, 0x18, 0xFF,
	0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x00,
	0x18, 0x18, 0x18, 0x18, 0x7E, 0x3C, 0x18, 0x00,
	0x00, 0x18, 0x0C, 0xFE, 0x0C, 0x18, 0x00, 0x00,
	0x00, 0x30, 0x60, 0xFE, 0x60, 0x30, 0x00, 0x00,
	0x00, 0x00, 0xC0, 0xC0, 0xC0, 0xFE, 0x00, 0x00,
	0x00, 0x24, 0x66, 0xFF, 0x66, 0x24, 0x00, 0x00,
	0x00, 0x18, 0x3C, 0x7E, 0xFF, 0xFF, 0x00, 0x00,
	0x00, 0xFF, 0xFF, 0x7E, 0x3C, 0x18, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x10, 0x00,	// !
	0x24, 0x24, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00,	// "
	0x14, 0x14, 0x7F, 0x28, 0xFE, 0x50, 0x50, 0x00,	// #
	0x10, 0x3C, 0x50, 0x30, 0x18, 0x14, 0x78, 0x10,	// $
	0x61, 0x92, 0x64, 0x18, 0x26, 0x49, 0x86, 0x00,	// %
	0x20, 0x50, 0x50, 0x62, 0x92, 0x8C, 0x7C, 0x00,	// &
	0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,	// '
	0x06, 0x08, 0x10, 0x10, 0x10, 0x10, 0x08, 0x06,	// (
	0x60, 0x10, 0x08, 0x08, 0x08, 0x08, 0x10, 0x60,	// )
	0x10, 0x52, 0x24, 0x3C, 0x24, 0x00, 0x00, 0x00,	// *
	0x00, 0x00, 0x10, 0x10, 0x7C, 0x10, 0x10, 0x00,	// +
	0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x10, 0x20,	// ,
	0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00,	// -
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00,	// .
	0x02, 0x04, 0x08, 0x08, 0x10, 0x10, 0x20, 0x40,	// /
	0x18, 0x24, 0x42, 0x42, 0x42, 0x24, 0x18, 0x00,	// 0
	0x30, 0xD0, 0x10, 0x10, 0x10, 0x10, 0xFE, 0x00,	// 1
	0x78, 0x04, 0x04, 0x18, 0x20, 0x40, 0x7C, 0x00,	// 2
	0x78, 0x04, 0x08, 0x30, 0x0C, 0x04, 0x78, 0x00,	// 3
	0x18, 0x28, 0x48, 0x88, 0xFC, 0x08, 0x08, 0x00,	// 4
	0x7C, 0x40, 0x78, 0x04, 0x04, 0x04, 0x78, 0x00,	// 5
	0x1C, 0x20, 0x5C, 0x62, 0x42, 0x22, 0x1C, 0x00,	// 6
	0x7E, 0x02, 0x04, 0x08, 0x10, 0x20, 0x20, 0x00,	// 7
	0x3C, 0x42, 0x24, 0x3C, 0x46, 0x42, 0x3C, 0x00,	// 8
	0x38, 0x44, 0x42, 0x46, 0x3A, 0x04, 0x38, 0x00,	// 9
	0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x18, 0x00,	// :
	0x00, 0x00, 0x30, 0x00, 0x00, 0x30, 0x10, 0x20,	// ;
	0x00, 0x00, 0x02, 0x0C, 0x30, 0x0C, 0x02, 0x00,	// <
	0x00, 0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00,	// =
	0x00, 0x00, 0x40, 0x30, 0x0C, 0x30, 0x40, 0x00,	// >
	0x7C, 0x42, 0x04, 0x08, 0x10, 0x00, 0x10, 0x00,	// ?
	0x1E, 0x22, 0x4E, 0x52, 0x5F, 0x20, 0x1C, 0x00,	// @
	0x00, 0x18, 0x24, 0x24, 0x7E, 0x42, 0x81, 0x00,	// A
	0x00, 0x7C, 0x42, 0x7C, 0x42, 0x42, 0x7C, 0x00,	// B
	0x00, 0x3E, 0x40, 0x80, 0x80, 0x40, 0x3E, 0x00,	// C
	0x00, 0x78, 0x44, 0x42, 0x42, 0x44, 0x78, 0x00,	// D
	0x00, 0x7E, 0x40, 0x7C, 0x40, 0x40, 0x7E, 0x00,	// E
	0x00, 0x7E, 0x40, 0x7C, 0x40, 0x40, 0x40, 0x00,	// F
	0x00, 0x3E, 0x40, 0x80, 0x8E, 0x42, 0x3E, 0x00,	// G
	0x00, 0x42, 0x42, 0x7E, 0x42, 0x42, 0x42, 0x00,	// H
	0x00, 0x7C, 0x10, 0x10, 0x10, 0x10, 0x7C, 0x00,	// I
	0x00, 0x3C, 0x04, 0x04, 0x04, 0x04, 0x78, 0x00,	// J
	0x00, 0x42, 0x44, 0x78, 0x48, 0x44, 0x42, 0x00,	// K
	0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7E, 0x00,	// L
	0x00, 0xC6, 0xC6, 0xAA, 0xAA, 0x92, 0x82, 0x00,	// M
	0x00, 0x42, 0x62, 0x52, 0x4A, 0x46, 0x42, 0x00,	// N
	0x00, 0x38, 0x44, 0x82, 0x82, 0x44, 0x38, 0x00,	// O
	0x00, 0x7C, 0x42, 0x42, 0x7C, 0x40, 0x40, 0x00,	// P
	0x00, 0x38, 0x44, 0x82, 0x82, 0x44, 0x38, 0x06,	// Q
	0x00, 0x78, 0x44, 0x44, 0x78, 0x4C, 0x46, 0x00,	// R
	0x00, 0x3E, 0x40, 0x3C, 0x02, 0x02, 0x7C, 0x00,	// S
	0x00, 0xFE, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00,	// T
	0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00,	// U
	0x00, 0x81, 0x42, 0x44, 0x24, 0x38, 0x10, 0x00,	// V
	0x00, 0x81, 0x91, 0x5A, 0x5A, 0x6A, 0x24, 0x00,	// W
	0x00, 0x81, 0x66, 0x18, 0x18, 0x66, 0x81, 0x00,	// X
	0x00, 0x82, 0x44, 0x28, 0x10, 0x10, 0x10, 0x00,	// Y
	0x00, 0xFE, 0x02, 0x0C, 0x30, 0x40, 0xFE, 0x00,	// Z
	0x1E, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1E,	// [
	0x40, 0x20, 0x10, 0x10, 0x08, 0x08, 0x04, 0x02,	// backslash
	0x78, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x78,	// ]
	0x10, 0x10, 0x28, 0x28, 0x44, 0x00, 0x00, 0x00,	// ^
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,	// _
	0x10, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	// `
	0x00, 0x00, 0x38, 0x04, 0x3C, 0x44, 0x3E, 0x00,	// a
	0x40, 0x40, 0x5C, 0x62, 0x42, 0x42, 0x7C, 0x00,	// b
	0x00, 0x00, 0x3E, 0x40, 0x40, 0x40, 0x3E, 0x00,	// c
	0x02, 0x02, 0x3E, 0x42, 0x42, 0x42, 0x3E, 0x00,	// d
	0x00, 0x00, 0x3C, 0x42, 0x7E, 0x40, 0x3E, 0x00,	// e
	0x1E, 0x20, 0xFE, 0x20, 0x20, 0x20, 0x20, 0x00,	// f
	0x00, 0x00, 0x3E, 0x42, 0x42, 0x3E, 0x02, 0x3C,	// g
	0x40, 0x40, 0x5E, 0x62, 0x42, 0x42, 0x42, 0x00,	// h
	0x18, 0x00, 0x78, 0x08, 0x08, 0x08, 0x08, 0x00,	// i
	0x18, 0x00, 0x78, 0x08, 0x08, 0x08, 0x08, 0x70,	// j
	0x40, 0x40, 0x44, 0x48, 0x70, 0x48, 0x44, 0x00,	// k
	0x78, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00,	// l
	0x00, 0x00, 0xB6, 0xDA, 0x92, 0x92, 0x92, 0x00,	// m
	0x00, 0x00, 0x5E, 0x62, 0x42, 0x42, 0x42, 0x00,	// n
	0x00, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x3C, 0x00,	// o
	0x00, 0x00, 0x5C, 0x62, 0x42, 0x7C, 0x40, 0x40,	// p
	0x00, 0x00, 0x3E, 0x42, 0x42, 0x3E, 0x02, 0x02,	// q
	0x00, 0x00, 0x5C, 0x64, 0x40, 0x40, 0x40, 0x00,	// r
	0x00, 0x00, 0x3C, 0x60, 0x18, 0x04, 0x78, 0x00,	// s
	0x00, 0x20, 0xFC, 0x20, 0x20, 0x20, 0x1C, 0x00,	// t
	0x00, 0x00, 0x42, 0x42, 0x42, 0x46, 0x7A, 0x00,	// u
	0x00, 0x00, 0x82, 0x44, 0x44, 0x28, 0x10, 0x00,	// v
	0x00, 0x00, 0x81, 0xD3, 0x5A, 0x6C, 0x24, 0x00,	// w
	0x00, 0x00, 0x42, 0x24, 0x18, 0x24, 0x42, 0x00,	// x
	0x00, 0x00, 0x82, 0x44, 0x28, 0x10, 0x20, 0xC0,	// y
	0x00, 0x00, 0x7E, 0x06, 0x18, 0x20, 0x7E, 0x00,	// z
	0x0C, 0x10, 0x10, 0x60, 0x10, 0x10, 0x10, 0x0C,	// {
	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00,	// |
	0x30, 0x08, 0x08, 0x06, 0x08, 0x08, 0x08, 0x30,	// }
	0x00, 0x00, 0x00, 0x71, 0x8E, 0x00, 0x00, 0x00,	// ~
	0x00, 0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0x00,
	0x7C, 0xC6, 0xC0, 0xC6, 0x7C, 0x0C, 0x06, 0x7C,
	0x00, 0xCC, 0x00, 0xCC, 0xCC, 0xCC, 0x76, 0x00,
	0x1C, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00, 
	0x7E, 0x81, 0x3C, 0x06, 0x3E, 0x66, 0x3B, 0x00,
	0xCC, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00, 
	0xE0, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00, 
	0x30, 0x30, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00,
	0x00, 0x00, 0x7C, 0xC6, 0xC0, 0x78, 0x0C, 0x38,
	0x7E, 0x81, 0x3C, 0x66, 0x7E, 0x60, 0x3C, 0x00,
	0xCC, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00,
	0xE0, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00,
	0xCC, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00, 
	0x7C, 0x82, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00, 
	0xE0, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
	0xC6, 0x10, 0x7C, 0xC6, 0xFE, 0xC6, 0xC6, 0x00,
	0x30, 0x30, 0x00, 0x78, 0xCC, 0xFC, 0xCC, 0x00, 
	0x1C, 0x00, 0xFC, 0x60, 0x78, 0x60, 0xFC, 0x00,
	0x00, 0x00, 0x7F, 0x0C, 0x7F, 0xCC, 0x7F, 0x00,
	0x3E, 0x6C, 0xCC, 0xFE, 0xCC, 0xCC, 0xCE, 0x00, 
	0x78, 0x84, 0x00, 0x78, 0xCC, 0xCC, 0x78, 0x00, 
	0x00, 0xCC, 0x00, 0x78, 0xCC, 0xCC, 0x78, 0x00,
	0x00, 0xE0, 0x00, 0x78, 0xCC, 0xCC, 0x78, 0x00, 
	0x78, 0x84, 0x00, 0xCC, 0xCC, 0xCC, 0x76, 0x00,
	0x00, 0xE0, 0x00, 0xCC, 0xCC, 0xCC, 0x76, 0x00,
	0x00, 0xCC, 0x00, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8,
	0xC3, 0x18, 0x3C, 0x66, 0x66, 0x3C, 0x18, 0x00,
	0xCC, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x78, 0x00,
	0x18, 0x18, 0x7E, 0xC0, 0xC0, 0x7E, 0x18, 0x18, 
	0x38, 0x6C, 0x64, 0xF0, 0x60, 0xE6, 0xFC, 0x00,
	0xCC, 0xCC, 0x78, 0x30, 0xFC, 0x30, 0xFC, 0x30,
	0xF8, 0xCC, 0xCC, 0xFA, 0xC6, 0xCF, 0xC6, 0xC3,
	0x0E, 0x1B, 0x18, 0x3C, 0x18, 0x18, 0xD8, 0x70,
	0x1C, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00,
	0x38, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00, 
	0x00, 0x1C, 0x00, 0x78, 0xCC, 0xCC, 0x78, 0x00, 
	0x00, 0x1C, 0x00, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 
	0x00, 0xF8, 0x00, 0xB8, 0xCC, 0xCC, 0xCC, 0x00,
	0xFC, 0x00, 0xCC, 0xEC, 0xFC, 0xDC, 0xCC, 0x00, 
	0x3C, 0x6C, 0x6C, 0x3E, 0x00, 0x7E, 0x00, 0x00, 
	0x38, 0x6C, 0x6C, 0x38, 0x00, 0x7C, 0x00, 0x00,
	0x18, 0x00, 0x18, 0x18, 0x30, 0x66, 0x3C, 0x00, 
	0x00, 0x00, 0x00, 0xFC, 0xC0, 0xC0, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xFC, 0x0C, 0x0C, 0x00, 0x00,
	0xC6, 0xCC, 0xD8, 0x36, 0x6B, 0xC2, 0x84, 0x0F,
	0xC3, 0xC6, 0xCC, 0xDB, 0x37, 0x6D, 0xCF, 0x03,
	0x18, 0x00, 0x18, 0x18, 0x3C, 0x3C, 0x18, 0x00, 
	0x00, 0x33, 0x66, 0xCC, 0x66, 0x33, 0x00, 0x00,
	0x00, 0xCC, 0x66, 0x33, 0x66, 0xCC, 0x00, 0x00, 
	0x22, 0x88, 0x22, 0x88, 0x22, 0x88, 0x22, 0x88,
	0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA,
	0xDB, 0xF6, 0xDB, 0x6F, 0xDB, 0x7E, 0xD7, 0xED,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0xF8, 0x18, 0x18, 0x18,
	0x18, 0x18, 0xF8, 0x18, 0xF8, 0x18, 0x18, 0x18,
	0x36, 0x36, 0x36, 0x36, 0xF6, 0x36, 0x36, 0x36,
	0x00, 0x00, 0x00, 0x00, 0xFE, 0x36, 0x36, 0x36, 
	0x00, 0x00, 0xF8, 0x18, 0xF8, 0x18, 0x18, 0x18,
	0x36, 0x36, 0xF6, 0x06, 0xF6, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
	0x00, 0x00, 0xFE, 0x06, 0xF6, 0x36, 0x36, 0x36,
	0x36, 0x36, 0xF6, 0x06, 0xFE, 0x00, 0x00, 0x00, 
	0x36, 0x36, 0x36, 0x36, 0xFE, 0x00, 0x00, 0x00,
	0x18, 0x18, 0xF8, 0x18, 0xF8, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xF8, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x1F, 0x00, 0x00, 0x00, 
	0x18, 0x18, 0x18, 0x18, 0xFF, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xFF, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x1F, 0x18, 0x18, 0x18,
	0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00,
	0x18, 0x18, 0x18, 0x18, 0xFF, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x1F, 0x18, 0x1F, 0x18, 0x18, 0x18, 
	0x36, 0x36, 0x36, 0x36, 0x37, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x37, 0x30, 0x3F, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x3F, 0x30, 0x37, 0x36, 0x36, 0x36,
	0x36, 0x36, 0xF7, 0x00, 0xFF, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xFF, 0x00, 0xF7, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x37, 0x30, 0x37, 0x36, 0x36, 0x36, 
	0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00,
	0x36, 0x36, 0xF7, 0x00, 0xF7, 0x36, 0x36, 0x36, 
	0x18, 0x18, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00,
	0x36, 0x36, 0x36, 0x36, 0xFF, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0xFF, 0x00, 0xFF, 0x18, 0x18, 0x18, 
	0x00, 0x00, 0x00, 0x00, 0xFF, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x3F, 0x00, 0x00, 0x00, 
	0x18, 0x18, 0x1F, 0x18, 0x1F, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x1F, 0x18, 0x1F, 0x18, 0x18, 0x18,
	0x00, 0x00, 0x00, 0x00, 0x3F, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0xFF, 0x36, 0x36, 0x36,
	0x18, 0x18, 0xFF, 0x18, 0xFF, 0x18, 0x18, 0x18, 
	0x18, 0x18, 0x18, 0x18, 0xF8, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x1F, 0x18, 0x18, 0x18, 
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
	0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
	0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 
	0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x76, 0xDC, 0xC8, 0xDC, 0x76, 0x00,
	0x00, 0x78, 0xCC, 0xF8, 0xCC, 0xF8, 0xC0, 0xC0,
	0x00, 0xFC, 0xCC, 0xC0, 0xC0, 0xC0, 0xC0, 0x00,
	0x00, 0x00, 0xFE, 0x6C, 0x6C, 0x6C, 0x6C, 0x00,
	0xFC, 0xCC, 0x60, 0x30, 0x60, 0xCC, 0xFC, 0x00,
	0x00, 0x00, 0x7E, 0xD8, 0xD8, 0xD8, 0x70, 0x00,
	0x00, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x60, 0xC0,
	0x00, 0x76, 0xDC, 0x18, 0x18, 0x18, 0x18, 0x00,
	0xFC, 0x30, 0x78, 0xCC, 0xCC, 0x78, 0x30, 0xFC,
	0x38, 0x6C, 0xC6, 0xFE, 0xC6, 0x6C, 0x38, 0x00,
	0x38, 0x6C, 0xC6, 0xC6, 0x6C, 0x6C, 0xEE, 0x00,
	0x1C, 0x30, 0x18, 0x7C, 0xCC, 0xCC, 0x78, 0x00,
	0x00, 0x00, 0x7E, 0xDB, 0xDB, 0x7E, 0x00, 0x00,
	0x06, 0x0C, 0x7E, 0xDB, 0xDB, 0x7E, 0x60, 0xC0,
	0x38, 0x60, 0xC0, 0xF8, 0xC0, 0x60, 0x38, 0x00,
	0x78, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x00,
	0x00, 0x7E, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00,
	0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x7E, 0x00,
	0x60, 0x30, 0x18, 0x30, 0x60, 0x00, 0xFC, 0x00,
	0x18, 0x30, 0x60, 0x30, 0x18, 0x00, 0xFC, 0x00,
	0x0E, 0x1B, 0x1B, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0xD8, 0xD8, 0x70,
	0x18, 0x18, 0x00, 0x7E, 0x00, 0x18, 0x18, 0x00,
	0x00, 0x76, 0xDC, 0x00, 0x76, 0xDC, 0x00, 0x00,
	0x38, 0x6C, 0x6C, 0x38, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
	0x0F, 0x0C, 0x0C, 0x0C, 0xEC, 0x6C, 0x3C, 0x1C,
	0x58, 0x6C, 0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00,
	0x70, 0x98, 0x30, 0x60, 0xF8, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	// Make sure array size is exactly 2k for the 8x8 font.
	KDebug_assert( sizeof( _8x8_font ) == 2048 );

	const uint8_t* buf = _8x8_font;

	// Define some magic numbers...
	enum Local_consts
	{
	    SEQ_MEM_MODE_REG_INDEX			= 4,
		SEQ_ODD_EVEN_DISABLE_BIT		= 2,
		GC_MODE_REG_INDEX				= 5,
		GC_HOST_ODD_EVEN_ENABLE_BIT		= 4,
		GC_MISC_REG_INDEX				= 6,
		GC_CHAIN_ODD_EVEN_ENABLE_BIT	= 1,
		GC_READ_MAP_SELECT_REG_INDEX	= 4,
		FONT_PLANE_NUMBER				= 2,
		SEQ_MAP_MASK_REG_INDEX			= 2,
		NUM_CHARS_IN_FONT				= 256,
		FONT_CHAR_BITMAP_SIZE			= 32,
		FONT_HEIGHT						= 8
	};

	// Turn off even-odd addressing (set flat addressing).
	// Assume: chain-4 addressing already off.
	IO_out8( VGA_SEQ_INDEX, SEQ_MEM_MODE_REG_INDEX );
	uint8_t seqMemMode = IO_in8( VGA_SEQ_DATA );	// Save old register value.
	IO_out8( VGA_SEQ_DATA, KMem_bitSet8( seqMemMode, SEQ_ODD_EVEN_DISABLE_BIT ) );

	// Turn off even-odd addressing.
	IO_out8( VGA_GC_INDEX, GC_MODE_REG_INDEX );
	uint8_t gcMode = IO_in8( VGA_GC_DATA );	// Save old register value.
	IO_out8( VGA_GC_DATA, KMem_bitClear8( gcMode, GC_HOST_ODD_EVEN_ENABLE_BIT ) );

	// Turn off even-odd addressing.
	IO_out8( VGA_GC_INDEX, GC_MISC_REG_INDEX );
	uint8_t gcMisc = IO_in8( VGA_GC_DATA );	// Save old register value.
	IO_out8( VGA_GC_DATA, KMem_bitClear8( gcMisc, GC_CHAIN_ODD_EVEN_ENABLE_BIT ) );

	// Write font to plane P4.
	// Set read plane.
	IO_out8( VGA_GC_INDEX, GC_READ_MAP_SELECT_REG_INDEX );
	uint8_t gcReadMapSelect = IO_in8( VGA_GC_DATA );	// Save old register value.
	IO_out8( VGA_GC_DATA, FONT_PLANE_NUMBER );

	// Set write plane.
	IO_out8( VGA_SEQ_INDEX, SEQ_MAP_MASK_REG_INDEX );
	uint8_t seqMapMask = IO_in8( VGA_SEQ_DATA );	// Save old register value.
	IO_out8( VGA_SEQ_DATA, KMem_bitSet8( 0, FONT_PLANE_NUMBER ) );

	// Write font 0.
	uint8_t* const VIDEO_MEM_BASE_BYTES = (uint8_t*) VIDEO_MEM_BASE;

	for (size_t i = 0; i < NUM_CHARS_IN_FONT; i++)
	{
		KMem_copy( VIDEO_MEM_BASE_BYTES + (i * FONT_CHAR_BITMAP_SIZE), buf, FONT_HEIGHT );
		buf += FONT_HEIGHT;
	}

	// Restore registers.
	IO_out8( VGA_SEQ_INDEX, SEQ_MAP_MASK_REG_INDEX );
	IO_out8( VGA_SEQ_DATA, seqMapMask );
	IO_out8( VGA_SEQ_INDEX, SEQ_MEM_MODE_REG_INDEX );
	IO_out8( VGA_SEQ_DATA, seqMemMode );
	IO_out8( VGA_GC_INDEX, GC_READ_MAP_SELECT_REG_INDEX );
	IO_out8( VGA_GC_DATA, gcReadMapSelect );
	IO_out8( VGA_GC_INDEX, GC_MODE_REG_INDEX );
	IO_out8( VGA_GC_DATA, gcMode );
	IO_out8( VGA_GC_INDEX, GC_MISC_REG_INDEX );
	IO_out8( VGA_GC_DATA, gcMisc );
}



/// \brief	Initializes all VGA registers for 90x60 text mode operation.
///
/// This function starts by blanking the screen. It does this by clearing the PAS (palette address
/// source) bit of the attribute controller index register. This is so that no weird visual
/// artifacts appear during the rest of initialization. Once this function returns, the caller
/// must call KernelDisplay_unblankScreen() to set the PAS bit again and put the new video mode
/// into effect.
///
/// \note
/// This code has been adapted from code written by Chris Giese. The original code and usage notes
/// are at this URL: http://my.execpc.com/~geezer/osd/graphics/modes.c. The values used to
/// initialize the VGA registers have been modified slightly so that the cursor is disabled and
/// blinking characters are disabled (i.e. -- 16-color backgrounds are possible).
void KernelDisplay_switchToPreferredVideoMode( void )
{
	static uint8_t _90x60_text[] =
	{
		// Miscellaneous Output Register.
		0xE7,
		// Sequencer registers.
		0x03, 0x01, 0x03, 0x00, 0x02,
		// CRT Controller registers.
		0x6B, 0x59, 0x5A, 0x82, 0x60, 0x8D, 0x0B, 0x3E,
		// Set bit 5 of the third byte to disable the cursor.
		0x00, 0x47, 0x26, 0x07, 0x00, 0x00, 0x00, 0x00,
		0xEA, 0x0C, 0xDF, 0x2D, 0x08, 0xE8, 0x05, 0xA3,
		0xFF,
		// Graphics Controller registers.
		0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00,
		0xFF,
		// Attribute Controller registers.
		0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07,
		0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
		// Clear bit 3 of first byte to disable blinking backgrounds and enable 16-color
		// backgrounds.
		0x04, 0x00, 0x0F, 0x08, 0x00,
	};

	const uint8_t* regs = _90x60_text;

	// Define some magic numbers...
	enum Local_consts
	{
		CRTC_END_HBLANK_REG_INDEX		= 0x03,
		CRTC_ENABLE_VRETRACE_BIT		= 7,
		CRTC_VRETRACE_END_REG_INDEX		= 0x11,
		CRTC_PROTECT_BIT				= 7
	};

	// First, blank out the screen by clearing the palette source bit in the attribute
	// index register. Having the screen blank while switching modes should avoid the
	// appearance of hokey visual artifacts.

	// Unlock 16-color palette and blank display.
	(void) IO_in8( VGA_INSTAT_READ );
	IO_out8( VGA_AC_INDEX, 0 );

	// Now proceed with the rest of the initialization...

	// Write Miscellaneous output register.
	IO_out8( VGA_MISC_WRITE, *regs++ );

	// Write Sequencer registers.
	for (uint8_t i = 0; i < VGA_NUM_SEQ_REGS; i++)
	{
		IO_out8( VGA_SEQ_INDEX, i );
		IO_out8( VGA_SEQ_DATA, *regs++ );
	}

	// Unlock CRTC registers.
	IO_out8( VGA_CRTC_INDEX, CRTC_END_HBLANK_REG_INDEX );
	IO_out8( VGA_CRTC_DATA, KMem_bitSet8( IO_in8( VGA_CRTC_DATA ), CRTC_ENABLE_VRETRACE_BIT ) );
	IO_out8( VGA_CRTC_INDEX, CRTC_VRETRACE_END_REG_INDEX );
	IO_out8( VGA_CRTC_DATA, KMem_bitClear8( IO_in8( VGA_CRTC_DATA ), CRTC_PROTECT_BIT ) );

	// Make sure they remain unlocked.
	KDebug_assert( KMem_isBitSet8( regs[CRTC_END_HBLANK_REG_INDEX], CRTC_ENABLE_VRETRACE_BIT ) );
	KDebug_assert( !KMem_isBitSet8( regs[CRTC_VRETRACE_END_REG_INDEX], CRTC_PROTECT_BIT ) );

	// Write CRTC registers.
	for (uint8_t i = 0; i < VGA_NUM_CRTC_REGS; i++)
	{
		IO_out8( VGA_CRTC_INDEX, i );
		IO_out8( VGA_CRTC_DATA, *regs++ );
	}

	// Write Graphics Controller registers.
	for (uint8_t i = 0; i < VGA_NUM_GC_REGS; i++)
	{
		IO_out8( VGA_GC_INDEX, i );
		IO_out8( VGA_GC_DATA, *regs++ );
	}

	// Write Attribute Controller registers.
	for (uint8_t i = 0; i < VGA_NUM_AC_REGS; i++)
	{
		(void) IO_in8( VGA_INSTAT_READ );
		IO_out8( VGA_AC_INDEX, i );
		IO_out8( VGA_AC_WRITE, *regs++ );
	}
}



/// \brief	Locks the 16-color palette and unblanks the display by setting the PAS bit of the
///			attribute controller index register.
void KernelDisplay_unblankScreen( void )
{
	// Define some magic numbers...
	enum Local_consts
	{
		ATTR_ADDR_PALETTE_SOURCE_BIT = 0x20
	};

	// Lock 16-color palette and unblank display.
	(void) IO_in8( VGA_INSTAT_READ );
	IO_out8( VGA_AC_INDEX, ATTR_ADDR_PALETTE_SOURCE_BIT );
}



// Public functions.

void KernelDisplay_init( void )
{
	KDebug_assert( Processor_areInterruptsDisabled() );

	// NOTE: Casting away volatile is OK here, since this method is supposed to be called in a
	// mutually-exclusive manner.
	KernelDisplay_reset( (KernelDisplay*) &s_instance );
}


volatile KernelDisplay* KernelDisplay_getInstance( void )
{
	return &s_instance;
}


void KernelDisplay_clear( KernelDisplay* kdisplay )
{
	KDebug_assertArg( kdisplay != NULL );

	uint16_t* destBegin				= VIDEO_MEM_BASE;
	const uint16_t* const destEnd	= VIDEO_MEM_BASE + (KDISPLAY_NUM_COLUMNS * KDISPLAY_NUM_ROWS);

	uint16_t attributeMask	= KernelDisplay_makeAttributeMask( kdisplay );
	uint16_t displayData	= KernelDisplay_makeDisplayData( ' ', attributeMask );

	while (destBegin != destEnd)
	{
		*destBegin++ = displayData;	// Can't use KMem_set() with 16-bit values.
	}

	kdisplay->m_column	= 0;
	kdisplay->m_row		= 0;
}


void KernelDisplay_print( KernelDisplay* kdisplay, const char buffer[], size_t length )
{
	KDebug_assertArg( kdisplay != NULL );
	KDebug_assertArg( buffer != NULL );

	// Maximum number of characters that can fit on the screen at a time (leaving room for one
	// more in the bottom-right corner).
	const size_t MAX_CHARS = (KDISPLAY_NUM_ROWS * KDISPLAY_NUM_COLUMNS) - 1;

	// Actual number of characters up to (but not including) the current output location.
	int numChars = kdisplay->m_row * KDISPLAY_NUM_COLUMNS + kdisplay->m_column;

	uint16_t*	dest;
	const char*	source;

	const char* strBegin	= buffer;
	const char* strEnd		= strBegin + length;

	if (length + numChars <= MAX_CHARS)
	{
		// No need to scroll or truncate, just blast out the characters.
		dest	= VIDEO_MEM_BASE + numChars;
		source	= strBegin;
	}
	else if (length <= MAX_CHARS)
	{
		// See how many times we have to scroll. Start by figuring out how many characters too
		// many we have.
		int numTooMany = length + numChars - MAX_CHARS;

		// Now figure out how many lines too many that is equivalent to. The + 1 is for the
		// partial line that gets truncated by the division. Even if numTooMany is an exact
		// multiple of KDISPLAY_NUM_COLUMNS, we still want to scroll one extra time because there
		// isn't room for the "next" character at the bottom-right corner.
		int linesTooMany = (numTooMany / KDISPLAY_NUM_COLUMNS) + 1;

		// Scroll enough lines to create room.
		KernelDisplay_scroll( kdisplay, linesTooMany );
		kdisplay->m_row -= linesTooMany;	// Keep relative position of the output to the text.

		// Update numChars to reflect the changes done by scrolling.
		numChars -= linesTooMany * KDISPLAY_NUM_COLUMNS;

		dest	= VIDEO_MEM_BASE + numChars;
		source	= strBegin;
	}
	else
	{
		// Truncation case.
		dest	= VIDEO_MEM_BASE;		// Start at the beginning of video memory.
		source	= strEnd - MAX_CHARS;	// Truncate the beginning of the string.
	}

	uint16_t attributeMask = KernelDisplay_makeAttributeMask( kdisplay );
	while (source != strEnd)
	{
		*dest++ = KernelDisplay_makeDisplayData( *source++, attributeMask );
	}

	// Update the current output position.
	ptrdiff_t currentChar = (ptrdiff_t) (dest - VIDEO_MEM_BASE);
	kdisplay->m_row		= currentChar / KDISPLAY_NUM_COLUMNS;
	kdisplay->m_column	= currentChar % KDISPLAY_NUM_COLUMNS;
}


KernelDisplayColor KernelDisplay_getBackgroundColor( const KernelDisplay* kdisplay )
{
	KDebug_assertArg( kdisplay != NULL );
	return kdisplay->m_backgroundColor;
}


KernelDisplayColor KernelDisplay_getForegroundColor( const KernelDisplay* kdisplay )
{
	KDebug_assertArg( kdisplay != NULL );
	return kdisplay->m_foregroundColor;
}


void KernelDisplay_setBackgroundColor(
	KernelDisplay*		kdisplay,
	KernelDisplayColor	backgroundColor
)
{
	KDebug_assertArg( kdisplay != NULL );
	kdisplay->m_backgroundColor = backgroundColor;
}


void KernelDisplay_setForegroundColor(
	KernelDisplay*		kdisplay,
	KernelDisplayColor	foregroundColor
)
{
	KDebug_assertArg( kdisplay != NULL );
	kdisplay->m_foregroundColor = foregroundColor;
}


void KernelDisplay_newLine( KernelDisplay* kdisplay )
{
	KDebug_assertArg( kdisplay != NULL );

	kdisplay->m_column = 0;

	if (kdisplay->m_row + 1 < KDISPLAY_NUM_ROWS)
	{
		kdisplay->m_row++;
	}
	else
	{
		KernelDisplay_scroll( kdisplay, 1 );
	}
}


void KernelDisplay_tab( KernelDisplay* kdisplay )
{
	KDebug_assertArg( kdisplay != NULL );

	if (kdisplay->m_column + TAB_SIZE >= KDISPLAY_NUM_COLUMNS)
	{
		KernelDisplay_newLine( kdisplay );
	}
	kdisplay->m_column += TAB_SIZE;
}


void KernelDisplay_reset( KernelDisplay* kdisplay )
{
	KDebug_assertArg( kdisplay != NULL );

	// Initialize the instance.
	KernelDisplay_switchToPreferredVideoMode();
	KernelDisplay_initFont();

	kdisplay->m_backgroundColor	= DEFAULT_BACKGROUND_COLOR;
	kdisplay->m_foregroundColor	= DEFAULT_FOREGROUND_COLOR;

	// Clear to default background. This also initializes row and column.
	KernelDisplay_clear( kdisplay );

	// Now that everything is in place, make it all visible on the screen.
	KernelDisplay_unblankScreen();
}


